{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Skills\"\n",
        "format: html\n",
        "editor: visual\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "Through my coursework at UBC, I am proficient in using R, Python, and GIS softwares to tackle data processing and geospatial analysis. Here are a few excerpts of my work:\n",
        "\n",
        "#Python\n",
        "\n",
        "My research into forest disturbance ecology relied heavily on the Vegetation Resource Index produced by the Government of Canada. These data are available as geodatabases which is best handled using python to extract variables of interest. \n"
      ],
      "id": "5a88f93d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Python script for filtering vegetation data and spatial analysis\n",
        "import os\n",
        "import arcpy\n",
        "py -m pip install jupyter\n",
        "# Set the directory path where the data is stored\n",
        "data_dir_path = r\"path/to/working/directory\"\n",
        "print(f\"Data Directory: {data_dir_path}\")\n",
        "\n",
        "# Set ArcPy workspace to a specific geodatabase\n",
        "arcpy.env.workspace = os.path.join(data_dir_path, \"veg_comp_2010.gdb\")\n",
        "\n",
        "# Allow overwriting of outputs\n",
        "arcpy.env.overwriteOutput = True\n",
        "\n",
        "# Define a scratch workspace for temporary files\n",
        "scratch_gdb_fpath = os.path.join(data_dir_path, \"scratch.gdb\")\n",
        "print(f\"Scratch Geodatabase Path: {scratch_gdb_fpath}\")\n",
        "\n",
        "# List all feature classes in the current workspace\n",
        "fc_list = arcpy.ListFeatureClasses()\n",
        "print(f\"Feature Classes in Workspace: {fc_list}\")\n",
        "\n",
        "# Check out the Spatial Analyst extension (if required)\n",
        "arcpy.CheckOutExtension(\"Spatial\")\n",
        "\n",
        "# Define the input shapefile and output shapefile paths\n",
        "input_shapefile = os.path.join(data_dir_path, \"VEG_COMP_LYR_R1_POLY.shp\")\n",
        "output_shapefile = os.path.join(data_dir_path, \"AspenDom_2010_VRI.shp\")\n",
        "\n",
        "# Specify the attribute field and value for filtering\n",
        "attribute_name = \"FHF\"  \n",
        "attribute_value = \"ID6\"\n",
        "\n",
        "# Create a SQL query to filter the features\n",
        "query = f\"{attribute_name} = '{attribute_value}'\"\n",
        "\n",
        "# Perform the selection and save it to a new shapefile\n",
        "arcpy.Select_analysis(in_features=input_shapefile, out_feature_class=output_shapefile, where_clause=query)\n",
        "\n",
        "print(f\"Filtered polygons with {attribute_name} = {attribute_value} saved to {output_shapefile}.\")\n",
        "\n",
        "# Open a search cursor to find features that match the criteria\n",
        "matching_features = []\n",
        "with arcpy.da.SearchCursor(input_shapefile, [\"SHAPE@\", attribute_name]) as search_cursor:\n",
        "    for row in search_cursor:\n",
        "        if row[1] == attribute_value:\n",
        "            matching_features.append(row[0])  # Store matching geometries\n",
        "\n",
        "# If matching features exist, create a new shapefile to store them\n",
        "if matching_features:\n",
        "    spatial_reference = arcpy.Describe(input_shapefile).spatialReference  # Get spatial reference\n",
        "\n",
        "    # Create a new feature class for filtered data\n",
        "    arcpy.CreateFeatureclass_management(\n",
        "        out_path=os.path.dirname(output_shapefile),\n",
        "        out_name=os.path.basename(output_shapefile),\n",
        "        geometry_type=\"POLYGON\",\n",
        "        spatial_reference=spatial_reference,\n",
        "    )\n",
        "\n",
        "    # Add the attribute field to the new feature class\n",
        "    arcpy.AddField_management(output_shapefile, attribute_name, \"TEXT\")\n",
        "\n",
        "    # Insert matching features into the new shapefile\n",
        "    with arcpy.da.InsertCursor(output_shapefile, [\"SHAPE@\", attribute_name]) as insert_cursor:\n",
        "        for geometry in matching_features:\n",
        "            insert_cursor.insertRow((geometry, attribute_value))\n",
        "\n",
        "    print(f\"Filtered features saved successfully to {output_shapefile}.\")\n",
        "else:\n",
        "    print(\"No matching features found.\")\n",
        "\n",
        "# Check in the 3D Analyst extension (if previously checked out)\n",
        "arcpy.CheckInExtension(\"3D\")\n",
        "\n",
        "# Set scratch workspace as the current workspace\n",
        "arcpy.env.workspace = scratch_gdb_fpath\n",
        "print(f\"Workspace set to scratch.gdb: {scratch_gdb_fpath}\")\n",
        "\n",
        "# Ensure ArcPy can overwrite existing files\n",
        "arcpy.env.overwriteOutput = True\n",
        "\n",
        "# Define study area shapefile path\n",
        "study_area = os.path.join(data_dir_path, \"study_area.shp\")\n",
        "\n",
        "# Define output file for the intersection analysis\n",
        "output_intersect = os.path.join(data_dir_path, \"2010_clipped_vri.shp\")\n",
        "\n",
        "# Perform an intersection between vegetation data and study area boundaries\n",
        "arcpy.analysis.Intersect([\"VEG_COMP_LYR_R1_POLY\", study_area], output_intersect)\n",
        "\n",
        "print(f\"Intersection analysis completed. Output saved to {output_intersect}.\")"
      ],
      "id": "24b335fb",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}